% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

%\documentclass[12pt]{article} % use larger type; default would be 10pt
%
%\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
%
%%%% Examples of Article customizations
%% These packages are optional, depending whether you want the features they provide.
%% See the LaTeX Companion or other references for full information.
%
%%%% PAGE DIMENSIONS
%\usepackage[top=1.05in, bottom=0.95in, left=0.75in, right=0.75in]{geometry}
%%\usepackage{geometry} % to change the page dimensions
%\geometry{a4paper} % or letterpaper (US) or a5paper or....
%% \geometry{margin=2in} % for example, change the margins to 2 inches all round
%% \geometry{landscape} % set up the page for landscape
%%   read geometry.pdf for detailed page layout information
%
%\usepackage{graphicx} % support the \includegraphics command and options
%
%% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent
%
%%%% PACKAGES
%\usepackage{booktabs} % for much better looking tables
%\usepackage{array} % for better arrays (eg matrices) in maths
%\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
%\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
%% These packages are all incorporated in the memoir class to one degree or another...
%
%%%% HEADERS & FOOTERS
%\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
%\pagestyle{fancy} % options: empty , plain , fancy
%%\renewcommand{\headrulewidth}{0pt} % customise the layout...
%\lhead{}\chead{}\rhead{}
%\lfoot{}\cfoot{\thepage}\rfoot{}
%
%%%% SECTION TITLE APPEARANCE
%\usepackage{sectsty}
%\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
%% (This matches ConTeXt defaults)
%
%%%% ToC (table of contents) APPEARANCE
%\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
%\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
%\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
%\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!
%\usepackage[UTF8]{ctex}
%\usepackage{fancyhdr}
%\usepackage{enumerate}
%\usepackage{indentfirst}
%\usepackage{extramarks}
%\usepackage{titling}


%!Mode:: "TeX:UTF-8"
\documentclass[a4paper,11pt,UTF8]{ctexart}

\usepackage{indentfirst} %缩进
\usepackage{xeCJK}    %使用系统字体
\usepackage{fancyhdr} %自定义页眉页脚
\pagestyle{empty}                   %不设置页眉页脚
\usepackage{amsmath, amsthm, amssymb, amsfonts} %数学公式
\usepackage[a4paper,left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
%\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry}.
\usepackage{booktabs} %插入表格
\usepackage[section]{placeins} %避免浮动
\usepackage{listings} %插入代码
\usepackage{ctex}     %中文宏包
\usepackage[svgnames, table]{xcolor} %彩色表格
\usepackage{algorithm}          %伪代码
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm,algpseudocode,float}
\usepackage{lipsum}
\usepackage{enumitem}           %调整列举环境
\usepackage{url}
\usepackage{fontspec,xunicode}
\defaultfontfeatures{Mapping=tex-text} %如果没有它，会有一些 tex 特殊字符无法正常使用，比如连字符。
\usepackage{titling}
\usepackage{extramarks}

\usepackage{graphicx}
\graphicspath{{imgs/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 缩进及行间距
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{22pt} %重新定义缩进长度
\setlength{\baselineskip}{20pt}  %定义行间距
%\renewcommand{\baselinestretch}{1.1} %定义行间距

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 列表设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setenumerate{fullwidth,itemindent=\parindent,listparindent=\parindent,itemsep=0ex,partopsep=0pt,parsep=0ex}
\setenumerate[2]{label=\alph*),leftmargin=1.5em}  %二级item设置
\setitemize{itemindent=38pt,leftmargin=0pt,itemsep=-0.4ex,listparindent=26pt,partopsep=0pt,parsep=0.5ex,topsep=-0.25ex}
\setdescription{itemindent=38pt,leftmargin=0pt,itemsep=-0.4ex,listparindent=26pt,partopsep=0pt,parsep=0.5ex,topsep=-0.25ex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 图的标题行间距设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\bottomcaption}{%
\setlength{\abovecaptionskip}{6pt}%
\setlength{\belowcaptionskip}{6pt}%
\caption}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 字体定义
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setmainfont{Times New Roman}  %默认英文字体.serif是有衬线字体sans serif无衬线字体
\setmonofont{Consolas}
\setCJKmainfont[ItalicFont={楷体}, BoldFont={黑体}]{宋体}%衬线字体 缺省中文字体为
\setCJKsansfont{黑体}
\punctstyle{hangmobanjiao}
%-----------------------xeCJK下设置中文字体------------------------------%
\setCJKfamilyfont{song}{SimSun}                             %宋体 song
\newcommand{\song}{\CJKfamily{song}}
\setCJKfamilyfont{fs}{FangSong}                      %仿宋  fs
\newcommand{\fs}{\CJKfamily{fs}}
\setCJKfamilyfont{ktgb}{KaiTi}                      %楷体2312 ktgb
\newcommand{\ktgb}{\CJKfamily{ktgb}}
\setCJKfamilyfont{yh}{Microsoft YaHei}                    %微软雅黑 yh
\newcommand{\yh}{\CJKfamily{yh}}
\setCJKfamilyfont{hei}{SimHei}                              %黑体  hei
\newcommand{\hei}{\CJKfamily{hei}}
\setCJKfamilyfont{hwxk}{STXingkai}                                %华文行楷  hwxk
\newcommand{\hwxk}{\CJKfamily{hwxk}}
%------------------------------设置字体大小------------------------%
\newcommand{\shiyanbaogao}{\fontsize{36pt}{\baselineskip}\selectfont}
\newcommand{\chuhao}{\fontsize{42pt}{\baselineskip}\selectfont}     %初号
\newcommand{\xiaochuhao}{\fontsize{36pt}{\baselineskip}\selectfont} %小初号
\newcommand{\yihao}{\fontsize{28pt}{\baselineskip}\selectfont}      %一号
\newcommand{\erhao}{\fontsize{21pt}{\baselineskip}\selectfont}      %二号
\newcommand{\xiaoerhao}{\fontsize{18pt}{\baselineskip}\selectfont}  %小二号
\newcommand{\sanhao}{\fontsize{15.75pt}{\baselineskip}\selectfont}  %三号
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}       %四号
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  %小四号
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    %五号
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   %小五号
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  %六号
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    %七号

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 图题字体大小相同
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{caption}
\captionsetup{font={footnotesize}}   % footnotesize = 9pt
\captionsetup[lstlisting]{font={footnotesize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 重定义枚举编号为 1),2)...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\labelenumi}{\theenumi)}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 重定义section标题
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\CTEXsetup[format={\sihao\CJKfamily{zhhei}\zihao{3}},%number={\chinese{section}},name={,、~},aftername={},
indent={0pt},beforeskip={6pt},afterskip={6pt},format+={\flushleft}]{section}
\CTEXsetup[format={\Large\bfseries\CJKfamily{zhkai}\zihao{4}},
%name={,.},number={\arabic{subsection}},aftername={},
indent={0pt},beforeskip={8pt},afterskip={6pt}]{subsection}
\CTEXsetup[format={\Large\bfseries\CJKfamily{zhkai}\zihao{4}},%name={(,)},number={\arabic{subsubsection}},aftername={},
indent={0pt},beforeskip={8pt},afterskip={6pt}]{subsubsection}
\CTEXsetup[number={\chinese{section}},name={附录, ~~ }]{appendix}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 标题名称中文化
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand\figurename{\hei 图}
\renewcommand\tablename{\hei 表}
\renewcommand\lstlistingname{\hei 代码}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}
\newtheorem{define}{定义}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 代码设置
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{
 columns=fixed,
 numbers=left,                                        % 在左侧显示行号
 numberstyle=\tiny\color{gray},                       % 设定行号格式
 frame=single,                                        % 单线背景边框
 breaklines=true,                                     % 设定LaTeX对过长的代码行进行自动换行
 keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
 numberstyle=\footnotesize\color{darkgray},
 commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
 stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
 showstringspaces=false,                              % 不显示字符串中的空格
 language=java,                                        % 设置语言
 basicstyle=\linespread{1.0}\xiaowuhao\ttfamily,                      % 字体字号
 %lineskip=10pt,
 %baselinestretch=1,
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 伪代码分页
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\ALG@name}{算法}
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother

%%% END Article customizations

%%% The "real" document content comes below...

\title{\textbf{Y86 Assembly IDE Project Report}}
\author{周芯怡 17307130354\\张作柏 17300240035}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\begin{sloppypar}
\maketitle

\pagestyle{fancy}
\lhead{\textbf{{\thetitle}}}
\rhead{\textbf{\nouppercase{\firstleftmark}}}
\cfoot{\thepage}

\tableofcontents
\clearpage



\section{概览}

\subsection{{\bf 开发环境}}

\begin{table}[h]
\begin{tabular}{ll}
{\bf 开发语言}   & JavaScript / HTML / CSS / Python  \\
{\bf 浏览器环境} & Chrome / Firefox / Safari \\
{\bf 第三方库}   & jQuery / Bootstrap                             
\end{tabular}
\end{table}

\subsection{{\bf 文件结构（新）}}

所有核心代码均收录在/Y86\_Assembly\_IDE/IDE文件夹下。

\noindent
本次Project的后端代码均在{\bf backend}目录下，说明如下：

\begin{table}[h]
\resizebox{\textwidth}{27mm}{
\begin{tabular}{llll}
{\bf kernel.py}          & 流水线控制逻辑  
&{\bf others/cc\underline{\hspace{0.5em}}stat.py}       & 状态码与条件码类 \\
{\bf parallel\_stages/Fetch.py}    & 流水线取指阶段  
&{\bf others/constant.py}& 常量的定义 \\
{\bf parallel\_stages/Decode.py}   & 流水线译码阶段  
&{\bf others/decoder.py} & 预处理.yo文件 \\
{\bf parallel\_stages/Execute.py}  & 流水线执行阶段  
&{\bf others/Init.py}    & 处理.yo文件 \\
{\bf parallel\_stages/Memory.py}   & 流水线访存阶段  
&{\bf others/little\underline{\hspace{0.5em}}endian.py} & 处理小端法 \\
{\bf parallel\_stages/WriteBack.py}& 流水线写回阶段  
&{\bf others/Help.py}      & Debug帮助文件 \\
{\bf memory\underline{\hspace{0.5em}}sys/memory.py} & 内存的实现  
&{\bf memory\underline{\hspace{0.5em}}sys/register.py} & 系统寄存器的实现 \\
{\bf memory\underline{\hspace{0.5em}}sys/piperegister.py} & 流水线寄存器的实现  
&{\bf encoder/encoder.py} & 汇编器 \\
{\bf others/thread.py} & 自定义线程  
&{\bf others/Global.py} & 封装Clock Cycle 
\end{tabular}}
\end{table}

\noindent
本次Project的前端代码收录在{\bf backend/js}目录下，前端素材收录在{\bf static/IDE}目录下，渲染模板收录在{\bf templates/IDE}目录下说明如下：

\begin{table}[h]
\begin{tabular}{ll}
{\bf templates/IDE/main.html}          & 前端界面  \\
{\bf static/IDE}    & 前端素材 \\
{\bf js/WriteCode.py}    & 前后端交互代码部分 \\  
{\bf js/WriteDisplay.py}    & 前后端交互显示框部分 \\  
{\bf js/WriteReg.py}    & 前后端交互寄存器部分 \\  
{\bf js/WriteStack.py}    & 前后端交互栈部分 \\  
{\bf js/WriteStage.py}    & 前后端交互流水线寄存器部分 \\  
{\bf js/WriteStat.py}    & 前后端交互流水线状态码部分 
\end{tabular}
\end{table}

\section{使用方法}
详见Manual.pdf

\clearpage
\section{设计}

\subsection{{\bf 动机}}

本次Project的基本要求是实现一个Y86流水线模拟器，这涉及到大量的逻辑和封装，以及对图形界面的需求。图形界面的几个选择有各种语言自带的图形库、Web、Unity、uwp等等。最后我们选择了Python+Web的组合，主要原因如下：

\begin{enumerate}
\item 我们能够熟练运用的语言只有C++，略知一二的有Python。Python{\bf 易上手}，且未来的{\bf 使用需求较高}，所以这里我们选择了Python作为我们的后端语言。

\item 相比其他语言，Python有着强大的库函数，使用便捷，大大减少了代码量。在不考虑效率的情况下，Python比C++更加友好，这尤其体现在后期代码量巨大的IDE设计上。

\item 由于C++和Python自带的图形界面并不出彩，所以我们选择了{\bf 显示更美观}、{\bf 交互性更好}的Web作前端。并且Python支持的框架较多，所以Python搭配Web是很好的选择。

\item Web是前端开发的基础，而Python更是当代程序员的必备技能。这两种工具的{\bf 学习资料较多}，且{\bf 未来用处更大}，不妨借此机会尝试一下。
\end{enumerate}

在github上参考了许多学长学姐的project之后，我们开始思考如何才能做出自己的特点。一些使用Unity作为前端的学长的作品，有非常抓人眼球的{\bf 3D显示效果}，这是Web所做不到的。但与此同时，换来的也是使用上的不便捷。同时也有许多用Web作为前端的学长，他们的Project往往风格十分朴素，前端{\bf 设计精简}，提供一些{\bf 基本的交互功能}，但仅此是不能做出我们自己的特色的。

再三考虑之后，我们打算做一个IDE。Web显示风格十分简洁，且不失美观，恰好符合作为调试工具的基本要求。而通过后端输入指令，更是符合程序员写代码的习惯。于是，我们打算开发一个简单的{\bf 书写Y86汇编代码的IDE}。

基于以上考虑，我们采用前端Web的形式，后端用Python实现所有的逻辑。

\subsection{{\bf 特点（新）}}

最终的版本实现了所有的基本功能：
\begin{itemize}
\item 实现了Y86指令集中的所有指令。
\item 实现了流水线控制逻辑。
\item 支持载入和解析.yo文件，并能在前端显示每个周期内流水线寄存器的数值。
\end{itemize}

在此基础上，我们还添加了许多新功能：
\begin{itemize}
\item 加入了{\bf iaddq}操作和{\bf 加载转发}优化(见课本练习4.57)。
\item 前端实时监视指定的栈、内存、寄存器中的值。
\item 实现了{\bf Y86汇编器}，从而能够接受.ys文件作为输入，也能保存汇编的结果。
\item 编译汇编代码，并显示返回{\bf 编译错误}。
\item 模仿GDB，实现了步进、断点等{\bf 22条动态调试指令}，调试功能强大。
\item 增加了Cache的模拟和显示
\item 可视化并行过程
\end{itemize}

\clearpage
\section{实现细节}

本节将对IDE的各个部件的具体实现细节进行详述，对于没有提及的细节请查看代码中的注释。

\subsection{{\bf 流水线}}

在{\bf backend/memory\underline{\hspace{0.5em}}sys}中，我们将内存、寄存器、系统寄存器封装成类，以便之后使用。封装和注释使合作完成代码的过程更加顺利，同时也使思路更清晰。

在{\bf backend/stages}中，我们按照顺序实现了流水线的五个阶段。最开始的时候，没有加入转发逻辑与控制逻辑。每个stage完成后，独立调试，确保没有局部的细节错误。之后，在Decode.py中加入转发逻辑，在kernel.py中加入控制逻辑，五个阶段联调。

在{\bf backend/others}中，添加读入的接口和后期所需要的类以及处理模块。因为这部分独立于整个流水线的设计，所以很适合分工来写，只需要声明好接口即可。

在实现流水线的过程中，我主要参考了书中的HCL代码。利用python的语法，可以写出与HCL相似的代码，降低了错误的概率，更加易于调试。五个阶段中，最简单的是$Memory$和$WriteBack$阶段，只用了1K的代码量就完成了。剩下的三个阶段比较繁琐：$Fetch$阶段需要考虑{\bf 指令的合法性}，{\bf 取出当前指令}，并{\bf 预测下一指令的地址}。$Decode$阶段需要处理{\bf 转发逻辑}，因为转发逻辑是后期加入的，且书上列出了HCL代码，所以难度并不大。$Execute$阶段实现{\bf ALU}，设置{\bf 状态码}和{\bf 条件码}，加入{\bf 加载转发}优化。不过相比之下，控制逻辑的实现更加困难。

在{\bf kernel.py}中，我们完成了CPU的{\bf 核心部分}，将五个阶段连接起来，并实现控制逻辑。五个阶段在执行的过程中，使用的均是上个周期中流水线寄存器的值，写入一个新的流水线寄存器中，当五个阶段都执行完后，才更新流水线寄存器。这样做的好处是，五个阶段{\bf 相互分离}，只需要使用上个周期的值，可以{\bf 假装并行}。但是由于流水线本身的设计问题，在加入转发逻辑后，$Decode$阶段是依赖于当前周期中$Execute$、$Memory$和$WriteBack$三个阶段的运算结果的，这导致当前的流水线设计并{\bf 不能}实现真正的并行。为了保证正确性，我们只好将五个阶段{\bf 倒序}执行，以处理结果依赖的问题。控制逻辑的实现全部在{\bf kernel.py}中体现，在更新寄存器的时候分别检查是否出现了三种问题，并做相对应的处理。同时在其中实现更新PC值的相应操作。

一些可能导致部分流水线寄存器的数值与其他实现不同的细节说明：
\begin{itemize}
\item 除去课本中规定的四种状态外，我们新增加了$BUB$和$NON$两种状态，分别表示$bubble$和在非指令集位置取指令。后者常会发生于代码结束，而没有遇到HLT，导致PC持续增加的情况下。
\item 加入了{\bf 加载转发}优化，通过增加在$Execute$阶段的特判，减少$bubble$的产生，详见课本练习4.57。
\end{itemize}

\subsection{{\bf 汇编器}}

作为一个IDE的基本需求，自然要实现一个Y86汇编器以实现编译汇编代码的需求。在实现YAS之后，可以通过书写.ys文件来造样例，这是非常方便的。

比较严谨的实现可能要参考{\bf 编译原理}这门课中的做法，但是时间有限，Y86的汇编代码比较简单，所以凭自己的想象写了一个汇编器，大致步骤如下：

\begin{itemize}
\item 格式化输入文件，用{\bf 正则表达式}去除备注和多余空格。由于我在读指令的时候是一行一行读的，所以暂时没办法处理跨行的注释。
\item 扫描并记录所有的{\bf label}，同时记录相应的指令地址。处理{\bf directives}，包括.pos、.align、.quad和.byte，其中对于.pos和.align要重新计算指令偏移量。
\item 再次扫描输入，对于每一条汇编指令，根据相应的语法格式{\bf 提取参数}并编码。这一步中要进行大量的特判，以保证能够检验出所有的非法指令，通过及时报错，来避免程序中断的问题。
\item 拼接结果，或是处理检验到的异常。
\end{itemize}

整个YAS实现的细节都在{\bf encoder/encoder.py}文件中，这是本PJ中代码量较大的一部分。

\subsection{{\bf Debug功能}}

为了完善IDE，改善用户体验，我们加入了相当数量的调试指令。其中大部分功能均是参考gdb中支持的指令及其语法格式。

大部分指令的实现细节都在{\bf Manual.pdf}中提到，此处只大致概述。
\begin{itemize}
\item {\bf $\#Step$指令集} \quad 运行程序。把原来执行指令的循环改成每次只执行一步，通过设置步长和断点，把控结束的时间。其中比较难实现的是$next$和$finish$两个指令，因为要牵扯到判断在哪一个函数中。我们可以通过$call$和$ret$的数量，来判断当前的递归深度。需要注意的是，{\bf 不能}统计在取指阶段取出的$call$和$ret$的数量，因为流水线的控制逻辑可能会导致误取指令。而为了体现步进的特点，$step$和$continue$指令均是查看{\bf 取指阶段}中取出的指令，所以这里在使用的时候会有一些偏差。
\item {\bf $\#Jump$指令集} \quad 跳转。最开始想通过向流水线中加入一条不存在的虚拟指令，以实现跳转操作。可是万恶的流水线控制逻辑有可能会将新加入的指令当做误取指令来处理！无奈，只好规定在跳的时候清空流水线寄存器中的信息，并{\bf 手动}执行$call$和$ret$的操作。
\item {\bf $\#Breakpoints$指令集} \quad 设置断点。实现相对简单，只需要用一个$list$来记录断点，并在执行的时候判断是否抵达断点即可。因为要维护断点的多条信息，所以这里如果把断点封装成类可能会更好些。
\item {\bf $\#Display$指令集} \quad 设置需要监视的值。和$\#Breakpoints$的实现类似，用一个$list$记录$Display$的表达式，前后端交互时读取相应的值并发送给前端。实现最简单的一个指令集。
\item {\bf $\#I\backslash O$指令集} \quad 输入/输出代码。在实现了YAS之后，我们可以很容易地支持加载并输出.yo和.ys操作。除此之外，我们还实现了{\bf 动态输入}代码的功能，当输入一段指令时，使用YAS进行译码，并将新得到的指令码加入当前指令集中。
\item {\bf $\#Others$指令集} \quad 其他功能。这里的几项功能逻辑都比较简单，不会遇到很大的问题。最麻烦的$help$指令，在参考了gdb的$help$文档后，改造完成，提升使用的{\bf 便捷性}。
\end{itemize}

\subsection{{\bf Web界面（新）}}

（原）

我们采用了HTML、CSS作为前端开发语言，同时借助了第三方库Bootstrap。利用这些强大的工具，我们得以比较轻松的实现较为美观的前端界面。具体的实现细节如下：

\begin{itemize}
\item Stack显示区和Code显示区：利用Bootstrap提供的表格功能实现
\item 状态和寄存器显示区：原本想用Bootstrap提供的选项卡功能实现，但是因为没能搞懂链接操作失败了。最后利用radio表单，让被选中的单选框对应的内容展示，实现了不同选项卡的切换。但缺点是每一次换选项卡时页面都会重新刷新
\item 流水线寄存器和Display展示区：同样利用表格排版
\end{itemize}

同时用CSS设置style，把每一个显示区设置为卡片风格，并进行页面的总体布局和美化。\\

（新）

本节主要介绍第三阶段中，我们在前端界面上所做的外观或功能方面的改进。
\paragraph{代码输入界面} 

因为我们想要尽可能模拟一个IDE，代码编辑功能是必不可少的，所以第三阶段我们新增加了代码的输入界面。在这个界面上可以输入代码，点击按钮汇编，同时还加入了{\bf 行号}、{\bf 汇编错误}提示等功能，使其看上去更像一个IDE。

\paragraph{调试界面}

调试界面在前两个阶段的基础上修改而成，在外观上大致相同，为了适应新加入的板块做了布局上的调整，也进行了一些美化。除此之外，还添加了以下功能：
\begin{itemize}
\item {\bf 指令输入：}为了操作的方便性，我们将之前在后端的指令输入输出都移到了前端，从此就不用再打开两个窗口使用IDE了。为此我们在界面顶部设置了指令输入框，加入了一个新的板块{\bf CMD}来显示相关的输出，并且能让不同类型的输出（如报错或提示）使用不同样式显示。
\item {\bf 流水线状态：}为了能更直观地体现多线程的实现效果，我们对流水线寄存器状态部分做了改进，让正在执行的阶段名称闪烁。当然，因为真正执行的速度非常快，这只是一个模拟效果，体现各个阶段开始的相对顺序。
\item {\bf 展示Cache：}我们增加了展示{\bf Cache}的部分，可以显示miss和hit的数量、每一个set每一行的tag、起始地址和结束地址，并采用不同的样式来区分valid line和invalid line。同时，在发生miss和hit时对应的line能分别闪烁红色和绿色并定位。
\item {\bf 代码显示定位：}代码显示自动跳转到当前执行的行。
\end{itemize}


\subsection{{\bf 前后端交互（新）}}

（原）

前后端交互主要利用了JavaScript。具体的实现是后端通过调用相应的WriteXXX函数把前端需要的数据整理成HTML格式，输入到.txt文件中。然后通过Load.js，每隔100ms把.txt文件中的内容加载到main.html文件对应的位置。这样就实现了前端的不断更新。\\

（新）

为了减少前后端交互过程中的文件传输，我们在第三阶段中放弃了用文件读写的方式交互，改用{\bf Django}框架。{\bf Django}是用{\bf Python}语言编写的{\bf Web}应用框架，因为我们使用的语言是{\bf Python 2.7}，所以不能支持{\bf Django}的最新版本，而使用的是{\bf Django 1.10}版本。

前后端交互是通过{\bf Request}和{\bf Response}实现的。当前端页面收到一个访问请求或者功能请求时，前端会向后端发送相应的{\bf Request}，后端在接收到{\bf Request}后，根据请求的内容进行相应的处理，并将处理的结果通过{\bf Response}发送给前端，前端进行相应的显示。

当收到一个访问请求时，前端会发送一个{\bf GET}请求给后端，后端收到请求后，渲染初始模板后，将相应的页面传输给前端显示。当收到一个功能请求时，例如编译、调试命令，前端会发送一个{\bf POST}请求给后端，这里使用{\bf POST}请求是因为可以更方便的传递较大的参数（代码、调试命令）；后端接受{\bf POST}请求后，会调用CPU进行处理。

因为我们不希望在每次命令后都要刷新来显示，所以我们在前端中使用了{\bf Ajax}来进行异步的局部刷新。但是这就需要同时返回几个{\bf HTML}版面，在后端中直接使用模板渲染只能返回一个{\bf HTML}版面，所以最后不得已我们还是选择了写{\bf Python}代码去得到{\bf HTML}代码，而非采用模板渲染。通过{\bf Python}代码得到几个部分的{\bf HTML}代码后，通过{\bf JSON}传输格式发送到前端，前端解析后再分别加载到页面的每个部分。

\subsection{{\bf 存储器结构（新）}}

第三阶段我们模拟了Cache的机制，在写内存时采用的是写回和写分配的策略。用Python提供的list和dictionary实现Cache的结构非常直观简单，功能写起来也很容易。唯一遇到的一个Bug是Python的list和dictionary做乘法时只复制了值的引用，所以一个修改时所有的都被改变了，要用for循环的写法规避这个问题。

另外，我们提供了让用户自定义Cache结构的功能，用户可以在前端输入期望的set数、block大小和每个set行数，我们会判断是否合法并修改Cache结构。

\subsection{{\bf 多线程Y86-64模拟器（新）}}

在最初的Y86实现版本中，虽然我们的五个阶段是在同一个Cycle中完成的，但是我们并没有实现五个阶段的同时执行。阶段三的任务之一就是通过各种语言自带的多线程函数，实现五个阶段的并行。

Python中提供了threading库来实现多线程，在每个Cycle开始时，为五个阶段分别创建线程并执行，在Cycle结束时，要通过join方法等待五个阶段执行结束。

这个阶段中遇到的几个问题：

\begin{itemize}
\item {\bf 阶段依赖：}目前流水线的设计有一点小问题，在转发阶段和执行阶段中判断CC是否修改需要后执行阶段和访存阶段的计算结果，所以必须等到相应阶段结束后再开始。这个问题的解决方法是，设置两个threading.Event表示执行阶段和访存阶段是否结束，当这两个阶段结束时，通过set方法设置结束信号。当需要当前某一阶段的值时，通过wait方法等待那一阶段的结束信号。
\item {\bf 函数返回值：}直接使用Python的threading函数是不能得到执行函数的返回值的，而我们的代码中Execute阶段的返回值是必要的。查阅资料后，我们使用了重新实现的MyThread类，以得到函数的返回值。
\end{itemize}

\subsection{{\bf 并行过程的前端显示（新）}}

为了更好地可视化五个阶段并行的过程，我们在前端加入了显示功能。在每个阶段开始执行时，相应的阶段按钮会亮起，结束时会再熄灭。因为在实际的执行过程中，并行过程非常快，所以我们不能按实际时间来执行。

首先，在每次执行指令时，后端发送一个阶段序列给前端，表示各阶段开始和结束的顺序。

前端在接收到序列之后，js会进行处理，每个200ms读取序列中的下一个字母，并通过修改css设定来实现亮或灭的效果。

因为js是异步非阻塞的，所以如果将控制亮灭的语句写成循环，就只会显示最后的颜色。为了实现js的sleep功能，调用了网上搜到的sleep函数，并将循环改成递归过程。

\clearpage
\section{测试}

本节将叙述对模拟器的测试和性能评估。

\subsection{{\bf 测试样例}}

为了更好地检验Y86模拟器的正确性，我们构造了几组数据，收录于{\bf test/new}目录下，说明如下：

\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
{\bf \#} & {\bf 测试文件}                          & {\bf 描述}                   \\ 
\hline
1        & ex32.yo	                   & 测试转发逻辑(见书4.32)        \\ 
\hline
2        & ex33.yo                       & 测试转发逻辑(见书4.33)           \\ 
\hline
3        & load\_forward.yo	        & 测试加载转发优化(见书4.37)            \\ 
\hline
4        & overflow.yo          & 测试数据溢出               \\ 
\hline
5        & INS1\~{}4.yo             & 测试非法指令                   \\ 
\hline
\end{tabular}
\end{table}

\subsection{{\bf 性能分析}}

暂未完成。

\clearpage
\section{开发过程}

本节将叙述Project的详细开发过程、遇到的问题和感想。

\subsection{{\bf 开发流程}}

从学长们那里得到的开发经验，如果两人明确分工一人做前端，一人做后端的话，工作量可能差异较大，并且两个人不能并行工作，效率很低。而且因为两个人都有必要熟悉流水线的逻辑，同时也需要掌握前端的开发技术，所以最后决定两人不做明确分工，在开发的过程中共同处理遇到的问题。

\paragraph{第一周(11.1\~{}11.4)}

开发过程中遇到的第一个问题是工具的选择。第一次做图形界面，面对许多陌生的开发工具，不知道其各自的优势与局限性在哪里，只好通过不断向学长和搜索引擎求助来得到比较好的答案。在决定组队之后，我们确定使用Python和Web作为开发工具，同时开始学习Python的使用和HTML、CSS、JS的基础知识。

\paragraph{第二周(11.5\~{}11.11)}

速成开发语言后，两人开始熟悉流水线细节，与此同时，实现简单的模块和类，以熟悉Python的使用。在第二周周五的时候，实现出流水线的第一版。自此开始分工，一人负责学习前后端交互的知识，另一人负责完成流水线的调试。

\paragraph{第三周(11.12\~{}11.18)}

有了做IDE的想法，发现需要在后端下比较大的功夫，决定尽早完成调试和前端界面的基本任务。开发过程中遇到的第二个问题是前后端交互方式的选择。尽管有许多现成的Web开发框架，但是在缺少网络相关知识的情况下，很难看懂相关的资料，并且调试的难度大大提高了。在学习了多种开发工具之后，最终决定放弃所有，使用最暴力的读写文件方式进行交互。完成流水线的调试，之后对前端页面进行初步布局，完成前后端的简单交互。某人周四晚上一时兴起实现了YAS。

\paragraph{第四周(11.19\~{}11.25)}

二人分工。一人负责美化前端，另一人负责参考学长们的Project以获取灵感\sout{(摸鱼)}。周末基本完成前端设计，某人一时兴起实现了Debug功能。

\paragraph{第五周(11.26\~{}12.2)}

基本完工，摸鱼一周。期间处理过一些前端和后端的bug，周末进行联调，书写报告的工作。

\paragraph{新技能get}
\begin{itemize}
\item Python
\item HTML5/CSS3/JavaScript
\item Flask/Django
\item jQuery/Bootstrap
\item JSON/ajax
\item Github
\item Latex
\end{itemize}

\subsection{{\bf 踩过的坑}}

\begin{itemize}
\item 课本中的溢出标志只考虑了正数的情况，所以不能直接引用。
\item Python中的long类型是没有上界的，这导致整数相加时不会产生溢出，需要手动设置溢出。
\item Python函数传参时，要注意对象是否可更改。
\item Python的全局变量是指同一模块中的变量，对模块外的全局变量就没法用global声明了。
\item Python中不写函数返回值可能会报AttributeError: 'NoneType' object has no attribute的神奇错误。
\item Python中几个空格连在一起和tab是不同的，混用会报SyntaxError。虽然是极智障的坑但是初学的时候很难发现。
\item HTML排版时最好用百分比确定元素的大小以适应不用尺寸的屏幕。
\end{itemize}

\subsection{{\bf 感想}}

\subsubsection{张作柏}
 
这是我的第一个Project，也是第一次和其他人合作做Project，的确是一次非常有趣的经历。

刚开始拿到PJ的时候，我是一头雾水的。虽然上课时老师讲的很清楚，但是在自己实现Y86的时候，却要考虑非常多的细节。但更让我头秃的是图形界面的设计，对于一个审美畸形的程序员来说，选择合适的工具，设计出一个美观的界面实在是太难了。幸好有几位非常nice的助教和学长指点，我才找到几条可以选择的路。说实话，本来我是没有组队的想法的，想自己干一票大的。但如果想要做出漂亮的PJ，要学的东西实在是太多了，自己一个人做太容易翻车。所以在我面前基本就只有两种选择，第一种是自己用C++和QT做，在熟练使用QT后，可能能做出一个质量还不错的PJ，第二种是找人组队，尝试一些完全没有接触过的技术，争取做出一个非常棒的PJ。因为分数的计算方式犹豫了一会，最后决定既然要做，那便做到最好，总要走出舒适区，尝试些全新的事物。之后嘛，就成功地抱到了队友的大腿。

确定了组队后，紧接而来的问题是如何分工。询问了之前学长们的经验，很多的队伍是一个人负责前端，另一个人负责后端，但是这就会导致两个人的并行效率非常差，而且一方出了问题另一方往往帮不上忙，那便失去了组队的意义。恰好我和队友都有学习Python和Web的需求，所以我们决定一起完成前端和后端。但确实分工是个大问题，这在后面写代码的时候也体现了出来，还好我的队友比较给力，解决了我代码里的各种问题，不过在以后更大工程的开发上，确实要仔细考虑分工的情况。

先说说各种工具的速成情况吧。在了解各种选择后，我便有了用Web做前端的想法，所以在第一个周末，就把HTML和CSS用一个晚上速成了一遍，大致了解这些工具的用途。HTML不同于我们以前写的C++，HTML的逻辑性不强，更多的是描述性，它更像是在描述网页中的每一个元素，这种语言的学习对于熟悉了C++的我来说，是一个巨大的挑战。而Python的速成相对就简单很多，参考了一些简单的代码和学长的PJ后，Python的基本用法就算是掌握了。为了合作的效率，我还粗略地学习了一下GitHub的使用。不过最难学的还是前后端交互的框架，在不断碰壁之后，我还是选择采用最粗暴的文件读写来进行传值，在这个阶段浪费了大概一个周的时间。再之后就是各种第三方库的学习，不过在实际开发中我用到的也并不是很多。最后，也是最关键的，实验报告的书写。这是我第一次正式尝试用Latex写报告，排版确实美观，也学会了一些基本的操作。感觉学了这么多的东西，是一次相当棒的经历了！

再谈谈idea的部分。做IDE的想法是我最先提出的，之后我的队友给我了许多非常棒的建议。在看过很多学长的报告之后，我发现用Web做的Project套路都很单一，很难做出彩。我发现许多Project虽然外表华丽，但并不实用，所以在如何提高实用性上，我动了点脑筋。本想像Python支持一个动态执行代码的功能，相当酷炫，但因为流水线自身的原因和支持的指令集，并不支持这样做，只好退而求其次，加了个动态输入代码的功能。最后的Debug功能实在是突发奇想，一个IDE没有调试功能怎么行呢？于是就从gdb上扒了一些好实现的功能来做了。

本来应该是重头戏的写代码部分，我似乎没啥想说的。这个Project虽然代码量比之前写过的代码都要多一点，但是除流水线外，基本都是各种特判，流水线的逻辑在书上也写的很清楚了，这其中基本没有涉及任何算法，所以调试的难度反而不如一些代码量较小的算法题。当然，调试工作主要还是由我的队友来做的，所以我也没有太多的发言权。最大的一个bug是由我队友发现的Python不会溢出的问题，在此之后，就没有太多难题了。

最后谈谈感想吧。合作的时候能遇到一个好队友真的是很棒的事，省去了很多烦恼，而且有人陪着一起学习新东西比自己单干要更容易坚持下来。其实，对于做PJ而言，学到的东西远比做出来的东西重要得多。假如没有这次PJ，我可能压根没有机会接触到这些前端开发的内容。总之，遇到了一个好队友，学到了很多想学的东西，做出了自己还算满意的项目，\sout{希望这样的PJ还能再来几个}！

\subsubsection{周芯怡} 

做这个pj最大的感想就是真的学到了很多东西吧。这之前我根本不敢想象有朝一日我也能愉快地用python，用HTML、CSS、Bootstrap写自己的web还能写得（或许）挺好看（在此感恩队友包容我大面积使用骚气的紫色）。而且这些全新的知识都是自己一点点上网学来的，自学的过程确实很艰辛，自己反复摸索试错的时候也总是让人有砸电脑的冲动，但是最后学下来了还是有满满的成就感。不管最终做出来怎么样或者这门课能拿个什么成绩，这段经历一定是难忘的。

至于代码本身，后端我做的主要是第一阶段的Debug，的确比较头疼，但由于队友的代码本身就没什么BUG，所以没有想象中的可怕。我写的比较多的是前端的部分，最大的感想就是要设计一个能入眼的界面真的太难了，尤其是在这种要展示的信息量特别大的情况下。我们的前端经历了两次大的改动，一直到现在的版本也不能说很漂亮。另外，排版过程中我对HTML的迷之定位深恶痛绝，或许是我自己不得其要领吧，整个排版工作是令人窒息的。除了界面的设计，功能上也还有不足的地方，比如我费尽心思做出来的拖拽功能被Load无情扼杀，用表单做选项卡的智障骚操作，还有到现在都没能实现的前端输入。希望接下来还能有机会继续完善。

然后就要大篇幅感谢我的队友了。

功利一点来说，以我这种水平，能和他一起做pj绝对是中彩票式的幸运。以我的实力，一个人能做出什么结果是不敢想的，过程肯定也是极其艰辛的。

就算无关分数，整个过程中我的队友也给了我很多宽容支持和鼓励。一开始，如果没有他来找我，我可能现在正在和C++与QT死磕。我的队友让我能走出舒适区，去学习更多更好的技能。其次，整个合作中我多次怀疑他要提刀来找我了。不知道有多少次，我自己都说，这个东西今天再做不出来明天就只有带着电脑跑路。但是第二天见到队友时他还是告诉我没关系慢慢来。到今天，看到他在实验感想中依然在鼓励我，当即下泪。怎么说呢，如果队友的代码里闪烁的是理性的光辉，那么他的感想里闪烁的就是人性的光辉。

做pj 也可以是一件有趣的事情呐。

\clearpage
\section{致谢}

\begin{itemize}
\item 感谢金城老师为我们解答流水线实现相关的问题。
\item 感谢几位助教给出了技术支持和宝贵的建议。
\item 感谢胡志峰学长提供他的PJ供我们参考。
\item 感谢解润芃、王辰浩等几位同学提供了构造测试样例的思路。
\end{itemize}


\end{sloppypar}
\end{document}
