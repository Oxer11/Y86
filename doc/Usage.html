<!DOCTYPE html>
<html>
<head>
  	<title>Y86 Assembly IDE 使用说明</title>
    <meta charset="utf-8">
  	<style>
  		body 
		{
			margin: 50px 100px;
			background:#e0ffff no-repeat fixed;
			font-family: "Liberation Sans", sans-serif;
		}
		font
		{
			padding: 25px 50px;
		}
		div
		{
			padding: 0px 15px;
		}
		pre{margin: 5px;padding: 5px;}
		p { margin: 5px;}
		h2{ margin: 10px;}
		h3{ margin: 5px;}
		h4{ margin: 5px;}
  	</style>
</head>

<body>
<h1 style="text-align:center;"> Y86 Assembly IDE 使用说明</h1>
<hr style="height:10px;border:none;border-top:10px groove skyblue;">

<h2>1 简介</h2>
<div>
	<p>Y86 Assembly IDE提供书写Y86汇编代码与动态调试的基本功能：</p>
	<ul>
	<li>支持从文件载入汇编代码或指令码和动态输入代码</li>
	<li></li>
	</ul>
</div>

<hr style=" height:2px;border:none;border-top:2px dotted #185598;" >

<h2>2 指令说明</h2>
<div>
	<h3>2.1 #Step指令集</h3>
	<div>
		<h4>2.1.1 step</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： step [N]
 不带参数时，执行下一个指令
 带参数时，参数[N]表示前进N步(除非程序中止)
 可缩写为s
</pre>
			<p><b>Implementation</b></p>
<pre>
 调用Step函数，设置步长为N，走到N步时停止。
</pre>
		</div>
	</div>
	<div>
		<h4>2.1.2 next</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： next [N]
 不带参数时，执行下一个指令，不会进入子函数
 带参数时，参数[N]表示前进N步(除非程序中止)
 可缩写为n
</pre>
			<p><b>Implementation</b></p>
<pre>
 在Step函数执行过程中，只统计当前函数中执行的指令数，直到执行N条语句结束。
</pre>
		</div>
	</div>
	<div>
		<h4>2.1.3 continue</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： continue
 继续执行当前程序，直到遇到断点或中止信号
 可缩写为c
</pre>
			<p><b>Implementation</b></p>
<pre>
 设置Step函数的步长为MAXCLOCK。
 每一步执行时，判断当前要取得指令是否位于断点处。若是，则中止。
</pre>
		</div>
	</div>
	<div>
		<h4>2.1.4 finish</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： finish
 执行当前程序，直到退出当前函数
</pre>
			<p><b>Implementation</b></p>
<pre>
 在Step函数执行过程中，记录递归的层数。
 当遇到call指令时，递归层数加一；当遇到ret指令时，递归层数减一。
 执行指令，直到遇到当前函数的ret指令。
</pre>
		</div>
	</div>
	
	<h3>2.2 #Jump指令集</h3>
	<div>
		<h4>2.2.1 jump</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： jump &ltlocation&gt
 令PC跳至位置&ltlocation&gt处
 &ltlocation&gt可以是指令地址，可以是合法的label
</pre>
			<p><b>Implementation</b></p>
<pre>
 直接将PC指向&ltlocation&gt会因为流水线的控制逻辑而出现问题。
 所以，此处直接放弃流水线中正在执行的指令，清空流水线寄存器，并将PC指向&ltlocation&gt。
</pre>
		</div>
	</div>
	<div>
		<h4>2.2.2 return</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： return
 直接跳出当前函数。
</pre>
			<p><b>Implementation</b></p>
<pre>
 最初想直接加一条虚拟的ret指令到流水线中，但是因为流水线的控制逻辑，可能会跳转失败。
 所以，此处直接放弃流水线中正在执行的指令，清空流水线寄存器，并手动执行ret指令。
</pre>
		</div>
	</div>
	<div>
		<h4>2.2.3 call</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： call &ltlabel&gt
 直接调用label函数。
</pre>
			<p><b>Implementation</b></p>
<pre>
 最初想直接加一条虚拟的call指令到流水线中，但是因为流水线的控制逻辑，可能会调用失败。
 所以，此处直接放弃流水线中正在执行的指令，清空流水线寄存器，并手动执行call指令。
</pre>
		</div>
	</div>
	
	<h3>2.3 #Breakpoints指令集</h3>
	<div>
		<h4>2.3.1 break</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： break &ltlocation&gt
 在位置&ltlocation&gt处设置断点。
</pre>
			<p><b>Implementation</b></p>
<pre>
 使用python中的list记录每个断点的信息，包括断点编号、断点位置、断点状态、断点是否删除。
 增加断点时，使用append命令，在list后面增加一个新的断点。
</pre>
		</div>
	</div>
	<div>
		<h4>2.3.2 info breakpoints</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： info breakpoints
 输出所有用户设置的未被删除的断点信息，包括断点编号、断点状态、断点位置。
</pre>
		</div>
	</div>
	<div>
		<h4>2.3.3 enable</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： enable &ltNUM&gt
 使编号为&ltNUM&gt的断点重新发挥作用，相对指令disable。
 若不带任何参数，则恢复所有断点。
</pre>
		</div>
	</div>
	<div>
		<h4>2.3.4 disable</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： disable &ltNUM&gt
 使编号为&ltNUM&gt的断点失去作用，即遇到该断点时不在停止，相对指令enable。
 若不带任何参数，则使所有断点失去作用。
</pre>
		</div>
	</div>
	<div>
		<h4>2.3.5 delete</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： delete &ltNUM&gt
 删除编号为&ltNUM&gt的断点，连其编号一同移除，即之后不再有编号为&ltNUM&gt的断点。
 若不带任何参数，则删除所有断点。
</pre>
		</div>
	</div>
	
	<h3>2.4 #Display指令集</h3>
	<div>
		<h4>2.4.1 display</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： display &ltEXP&gt
 在Display框中实时显示EXP变量的值。
 几种EXP的格式：
   REG &ltREGNAME&gt 例：REG %rax
     显示系统寄存器&ltREGNAME&gt的值，注意&ltREGNAME&gt必须以'%'开头。
   MEM &ltADDR&gt    例：MEM 0x200
     显示内存地址&ltADDR&gt中的值，注意&ltADDR&gt必须是十六进制表示。
   STACK &ltNUMID&gt 例：STACK 0
     显示系统栈顶第&ltNUMID&gt个元素的值，下标从0开始，注意&ltNUMID&gt必须是十进制表示。
</pre>
		</div>
	</div>
	<div>
		<h4>2.4.2 undisplay</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： undisplay &ltEXP&gt
 在Display框中取消显示EXP变量的值。
 几种EXP的格式：
   REG &ltREGNAME&gt 例：REG %rax
     显示系统寄存器&ltREGNAME&gt的值，注意&ltREGNAME&gt必须以'%'开头。
   MEM &ltADDR&gt    例：MEM 0x200
     显示内存地址&ltADDR&gt中的值，注意&ltADDR&gt必须是十六进制表示。
   STACK &ltNUMID&gt 例：STACK 0
     显示系统栈顶第&ltNUMID&gt个元素的值，下标从0开始，注意&ltNUMID&gt必须是十进制表示。
</pre>
		</div>
	</div>
	
	<h3>2.5 #I/O指令集</h3>
	<div>
		<h4>2.5.1 write</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： write &ltFILENAME&gt
 将指令码与汇编代码以.yo文件的格式写入文件&ltFILENAME&gt中。
</pre>
		</div>
	</div>
	<div>
		<h4>2.5.2 list</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： list
 将指令码与汇编代码以.yo文件的格式显示在屏幕上。
</pre>
		</div>
	</div>
	<div>
		<h4>2.5.3 load</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： load &ltFILENAME&gt
 清除之前所有的代码和状态
 从&ltFILENAME&gt中加载指令码和汇编码，&ltFILENAME&gt必须是.yo文件或.ys文件。
 当加载.yo类型文件时，可直接从中提取指令码
 当加载.ys类型文件时，调用YAS生成指令码，并记录所有label
</pre>
		</div>
	</div>
	<div>
		<h4>2.5.4 read</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： read [Enter]
 &ltAssembly Code&gt
 [Enter]
 动态输入汇编代码，附加在当前代码集合之后，可以调用之前的label，可以新建label。
</pre>
		</div>
	</div>
	
	<h3>2.6 #Others指令集</h3>
	<div>
		<h4>2.6.1 set</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： set &ltEXP&gt &ltvalue&gt
 几种EXP的格式：
   REG &ltREGNAME&gt 例：REG %rax
     显示系统寄存器&ltREGNAME&gt的值，注意&ltREGNAME&gt必须以'%'开头。
   MEM &ltADDR&gt    例：MEM 0x200
     显示内存地址&ltADDR&gt中的值，注意&ltADDR&gt必须是十六进制表示。
   STACK &ltNUMID&gt 例：STACK 0
     显示系统栈顶第&ltNUMID&gt个元素的值，下标从0开始，注意&ltNUMID&gt必须是十进制表示。
 将表达式&ltEXP&gt指定的值设为&ltvalue&gt。
</pre>
		</div>
	</div>
	<div>
		<h4>2.6.2 clear</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： clear
 清除当前所有代码和状态。
</pre>
		</div>
	</div>
	<div>
		<h4>2.6.3 help</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： help &ltCMD&gt
 显示&ltCMD&gt指令的使用说明。
 当不加参数时，显示所有指令组。
 当&ltCMD&gt为指令组时，显示该指令组内的所有指令简介。
 当&ltCMD&gt为某个指令时，显示该指令的使用方法。
</pre>
		</div>
	</div>
	<div>
		<h4>2.6.4 quit</h4>
		<div>
			<p><b>Usage</b></p>
<pre>
 格式： quit
 退出Y86 Assembly IDE。
</pre>
		</div>
	</div>
</div>

<hr style=" height:2px;border:none;border-top:2px dotted #185598;" >

<h2>3 注意事项</h2>
<div>
	<ul>
	<li>载入.yo文件时，不支持任何label操作。因为载入时直接读取指令码，所以无法对应label。</li>
	<li>直接输入回车[Enter]时，会执行上一条指令。</li>
	<li>载入文件时，会自动清除之前的所有代码与状态。</li>
	<li>支持#和/**/两种注释格式，暂不支持分行注释</li>
	</ul>
</div>
